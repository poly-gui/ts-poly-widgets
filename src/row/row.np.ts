// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufReader, NanoBufWriter } from "nanopack"

import { Widget } from "../widget/widget.np.js"
import type { TAlignment } from "../alignment/alignment.np.js"

class Row extends Widget {
	public static TYPE_ID = 1006836449

	constructor(
		public tag: number | null,
		public width: number,
		public height: number,
		public horizontalAlignment: TAlignment,
		public verticalAlignment: TAlignment,
		public children: Widget[],
	) {
		super(tag)
	}

	public static fromBytes(
		bytes: Uint8Array,
	): { bytesRead: number; result: Row } | null {
		const reader = new NanoBufReader(bytes)
		return Row.fromReader(reader)
	}

	public static fromReader(
		reader: NanoBufReader,
	): { bytesRead: number; result: Row } | null {
		let ptr = 28

		let tag: number | null
		if (reader.readFieldSize(0) >= 0) {
			tag = reader.readInt32(ptr)
			ptr += 4
		} else {
			tag = null
		}

		const width = reader.readDouble(ptr)
		ptr += 8

		const height = reader.readDouble(ptr)
		ptr += 8

		const horizontalAlignment = reader.readInt8(ptr) as TAlignment
		ptr += 1

		const verticalAlignment = reader.readInt8(ptr) as TAlignment
		ptr += 1

		const childrenLength = reader.readInt32(ptr)
		ptr += 4
		const children: Widget[] = new Array(childrenLength)
		for (let i = 0; i < childrenLength; i++) {
			const maybeIItem = Widget.fromReader(reader.newReaderAt(ptr))
			if (!maybeIItem) {
				return null
			}
			const iItem = maybeIItem.result
			ptr += maybeIItem.bytesRead
			children[i] = iItem
		}

		return {
			bytesRead: ptr,
			result: new Row(
				tag,
				width,
				height,
				horizontalAlignment,
				verticalAlignment,
				children,
			),
		}
	}

	public override get typeId(): number {
		return 1006836449
	}

	public override bytes(): Uint8Array {
		const writer = new NanoBufWriter(28)
		writer.writeTypeId(1006836449)

		if (this.tag) {
			writer.appendInt32(this.tag)
			writer.writeFieldSize(0, 4)
		} else {
			writer.writeFieldSize(0, -1)
		}

		writer.appendDouble(this.width)
		writer.writeFieldSize(1, 8)

		writer.appendDouble(this.height)
		writer.writeFieldSize(2, 8)

		writer.appendInt8(this.horizontalAlignment)
		writer.writeFieldSize(3, 1)

		writer.appendInt8(this.verticalAlignment)
		writer.writeFieldSize(4, 1)

		writer.appendInt32(this.children.length)
		let childrenByteLength = 4
		for (const iItem of this.children) {
			const iItemData = iItem.bytes()
			writer.appendBytes(iItemData)
			childrenByteLength += iItemData.byteLength
		}
		writer.writeFieldSize(5, childrenByteLength)

		return writer.bytes
	}

	public override bytesWithLengthPrefix(): Uint8Array {
		const writer = new NanoBufWriter(28 + 4, true)
		writer.writeTypeId(1006836449)

		if (this.tag) {
			writer.appendInt32(this.tag)
			writer.writeFieldSize(0, 4)
		} else {
			writer.writeFieldSize(0, -1)
		}

		writer.appendDouble(this.width)
		writer.writeFieldSize(1, 8)

		writer.appendDouble(this.height)
		writer.writeFieldSize(2, 8)

		writer.appendInt8(this.horizontalAlignment)
		writer.writeFieldSize(3, 1)

		writer.appendInt8(this.verticalAlignment)
		writer.writeFieldSize(4, 1)

		writer.appendInt32(this.children.length)
		let childrenByteLength = 4
		for (const iItem of this.children) {
			const iItemData = iItem.bytes()
			writer.appendBytes(iItemData)
			childrenByteLength += iItemData.byteLength
		}
		writer.writeFieldSize(5, childrenByteLength)

		writer.writeLengthPrefix(writer.currentSize - 4)

		return writer.bytes
	}
}

export { Row }
